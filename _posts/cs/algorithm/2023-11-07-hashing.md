---
title: "[Data Structure] Hashing"
date: 2023-11-07
categories: [CS, Algorithm]
tags: [Algorithm]
---

## Hashing

Hashing consists of **2 parts**.

- A <span style="font-weight: bold; background-color: yellow; color: black;">table</span> (an array) of size m(T[0..m-1]).
- A <span style="font-weight: bold; background-color: yellow; color: black;">hash function</span> ***h***, which maps a key into an index between 0 and m-1 inclusive.

## Problem with Hashing

2 keys may have the **same** hash value - a <span style="font-weight: bold; background-color: yellow; color: black;">collision</span>.

To solve *colilision*, we need:
- A good **hash function**, that avoids collision.
- A collision **resolution strategy**.

## Chaining (Open Hashing)

Keep a <span style="font-weight: bold; background-color: yellow; color: black;">linked list</span> of all elements that have the ***same hash value***.

![d](/assets/img/algorithm/chaining.png)

#### Analysis of Chaining

- `Insert` takes constant time **O(1)**.
- `Delete` takes constant time only if the pointer points to the node and the list is a *doubly linked list*, otherwise **O(n)**.
- `Searching` takes **O(n)** at worst case when all the keys are mapped to the same slot.

#### Simple Uniform Hashing

The *performance* of hashing depends a lot on <span style="font-weight: bold; background-color: yellow; color: black;">hash functions</span>. The hash function should ***map the keys in the universe as uniformly as possible over the m slots***. Moreover, the *m* slots should be given roughly the ***same number of elements***.

This ideal *hash function* is known as <span style="font-weight: bold; background-color: yellow; color: black;">simple uniform hashing</span>.

#### The Division Method

In this *hash function*, *k* stands for **key** and *m* stands for **table size**. 

With this *hash function*, the choice of *m* is very important.

- `h(k) = k mod m

A **good** *hash function* should use ***all the information*** provided by the keys.

Here are some rules to follow when choosing a good value for *m*:

1. *m* should not be a power of **2**.
2. *m* should not be a power of **10**, if application deals with **decimal numbers**.
3. Good value of *m* are prime numbers.

> If it is difficult to choose prime numbers, pick *m* such that it has no prime numbers less than **20**. (e.g., 23 x 31)
{: .prompt-info}

#### Multiplication Method

1. Pick a constant 0 < A < 1.
2. Take the fractional part of *k x A*.
3. Multiply the result by m.
4. Take the integer part of the result.
5. h(k) = int(frac(k x A) x m)

> **Note:** *A* should be a **irrational number**.
{: .prompt-info}

## Open Addressing (Closed Hashing)

Unlike `chaining`, all key-value pairs are stored in the hash table itself - *element T[m]*.

There are 2 advantages compared to `chaning`.

1. It saves time in not doing **memory allocation and de-allocation**.
   - In `chaining`, **collision** results in the creation of a new node in a linked list, which requires dynamic memory allocation.
2. It saves **space**.
   - Pointers take space in `chaining`. (4 bytes each on a 32-bit machine)
   - If given same amount of memory, we can afford a larger nuber of spots under `open addressing`, resulting in <span style="font-weight: bold; background-color: yellow; color: black;">fewer collision.</span>

  
  


